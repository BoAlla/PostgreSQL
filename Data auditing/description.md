# Теоретическая часть
Безопасность базы данных является одной из важных проблем администрирования. Существует несколько основных подходов к созданию подсистемы контроля и восстановления базы данных PostgreSQL. 

1)	<i>Утилита pg_dump - извлекает из PostgreSQL базу данных в скрипт-файл или в архив. </i>

Идея, стоящая за этим методом, заключается в генерации текстового файла с командами SQL, которые при выполнении на сервере пересоздадут базу данных в том же самом состоянии, в котором она была на момент выгрузки. </br>
Преимуществом данного способа является то, что вывод pg_dump обычно можно загрузить в более новые версии PostgreSQL, в то время как резервная копия на уровне файловой системы и непрерывное архивирование зависят от версии сервера. Метод с применением pg_dump будет работать при переносе базы данных на другую машинную архитектуру, например, при переносе с 32-битной на 64-битную версию сервера. </br>
Дампы, создаваемые pg_dump, являются внутренне согласованными, то есть, дамп представляет собой снимок базы данных на момент начала запуска pg_dump. pg_dump не блокирует другие операции с базой данных во время своей работы, исключением являются некоторые формы команды ALTER TABLE. 
Текстовые файлы, созданные pg_dump, предназначаются для последующего чтения программой psql. Дампы, выгруженные не в текстовом формате, восстанавливаются утилитой pg_restore. </br>
Программа pg_dump выгружает только одну базу данных в один момент времени и не включает в дамп информацию о ролях и табличных пространствах (так как это информация уровня кластера, а не самой базы данных). Для удобства создания дампа всего содержимого кластера баз данных существует утилита pg_dumpall, которая делает резервную копию всех баз данных кластера, а также сохраняет данные уровня кластера, такие как роли и определения табличных пространств. </br>

2)	<i>Резервное копирование файловой системы.</i> </br>

Альтернативной стратегией является непосредственное копирование файлов, в которых PostgreSQL хранит содержимое базы данных. Однако, существуют два ограничения, которые делают этот метод непрактичным или как минимум менее предпочтительным по сравнению с pg_dump: </br>
<ul>
 <li>Необходимо остановить сервер баз данных. Также сервер нужно будет остановить и перед восстановлением данных.</li>
 <li>Нельзя копировать отдельные таблицы или базы данных в соответствующих файлах или каталогах. Копирование на уровне файловой системы будет работать, только если выполняется полное копирование и восстановление всего кластера баз данных.</li>
</ul>
Размер копии на уровне файлов обычно больше, чем дампа SQL. Однако копирование на уровне файлов может выполняться быстрее.

3)	<i>Непрерывное архивирование и восстановление на момент времени (Point-in-Time Recovery, PITR) </i> </br>

Всё время в процессе работы PostgreSQL ведёт журнал предзаписи (WAL). Все транзакции, такие как INSERT, UPDATE, DELETE, записываются в WAL до того, как клиент получает результат транзакции. Прежде всего, журнал существует для безопасного восстановления после краха сервера: если происходит крах, целостность СУБД может быть восстановлена в результате «воспроизведения» записей, зафиксированных после последней контрольной точки. </br>
Программы pg_dump и pg_dumpall не создают копии на уровне файловой системы и не могут применяться как часть решения по непрерывной архивации. Создаваемые ими копии являются логическими и не содержат информации, необходимой для воспроизведения WAL. </br>
Как и обычное резервное копирование файловой системы, этот метод позволяет восстанавливать только весь кластер баз данных целиком, но не его части. Кроме того, для архивов требуется большое хранилище: базовая резервная копия может быть объёмной, а нагруженные системы будут генерировать многие мегабайты трафика WAL, который необходимо архивировать. Тем не менее, этот метод предпочитается во многих ситуациях, где необходима высокая надёжность. </br>

4)	<i>Логирование с помощью триггерной процедуры. </i> </br>

Методы на основе триггеров предполагают создание триггеров аудита в базе данных для регистрации всех событий, связанных с методами INSERT, UPDATE и DELETE. Когда функция срабатывает как триггер, в блоке верхнего уровня автоматически создаются несколько специальных переменных с определенными данными, которые можно использовать для последующего контроля и восстановления базы данных. Еще одним плюсом является то, что хранение сведений о событиях в базе данных позволяет при их анализе использовать возможности языка SQL – фильтрацию, поиск, и сортировку.

### Вывод
Итак, исследовав различные способы контроля и восстановления базы данных на определенный момент времени, можем сделать вывод, что в рамках данной работы целесообразно использовать метод триггерной процедуры, так как с помощью него удобнее всего восстанавливать данные о банковской карте на определенный момент времени и контролировать все изменения текущего баланса. Остальные методы необходимы, чтобы полностью восстанавливать копию таблицы базы данных или всей базы данных, что используется при полной утери информации и для чего потребуются большие объемы свободной памяти, ведь текущий баланс банковской карты клиента может меняться в любой момент времени и по многу раз, создавать при каждом случае копию всей базы данных не рационально. </br>

Рассмотрим логирование изменений с помощью триггерной процедуры более подробно. </br>

Логирование позволяет ответить на вопросы, что происходило, когда и при каких обстоятельствах. Без логов сложно понять, из-за чего появляется ошибка, если она возникает периодически и только при определенных условиях. При этом важно, чтобы пользователи, для которых ведутся логи, не имели к ним доступа. Ведение журнала логов является распространенным требованием во многих корпоративных базах данных с целью регистрации всех изменений. </br>
Контроль изменений с помощью логов позволяет решить следующие задачи: </br>
<ul>
 <li>Узнать кто, когда и откуда производил изменения данных, какие изменения;</li>
 <li>Настроить систему уведомлений в случае подозрительных действий в базе данных. Например, если в субботу ночью появится учетная запись с правами суперпользователя, система сразу зарегистрирует это событие и пришлет уведомление. Инженеры уточнят легитимность новой записи, чтобы предотвратить попытку несанкционированного доступа;</li>
 <li>Восстановить некоторые данные в соответствии с таблицей логов на определенный момент времени.</li>
</ul>
Журнал логов может помочь достичь нескольких дополнительных целей, таких как индивидуальная подотчетность, обнаружение вторжений, анализ проблем, сбор статистики. Примеры задач, решаемых с помощью логирования: </br>
<ul>
 <li>Выявление причин возникновения технических проблем, сбоев. К примеру, можно восстановить последовательность событий при инциденте, сделать выводы и выработать решения, которые предотвратят появление таких инцидентов в будущем;</li>
 <li>Сбор статистики по нагрузке базы данных;</li>
 <li>Установление индивидуальной ответственности: пользователи базы данных будут нести личную ответственность за свои действия, которые отслеживаются журналом аудита, потому что в нем фиксируется, кто внес изменения.</li>
</ul>
Логирование - хороший способ эффективно контролировать состояние базы данных. Вместе с сервисами мониторинга логирование существенно экономит время при расследовании тех или иных инцидентов. 

Таким образом, основная идея реализации логирования заключается в том, чтобы создать уникальную таблицу истории всех изменений. Для восстановления данных из логов можно использовать средства языка запросов SQL и процедурное расширение языка SQL - PL/pgSQL. В практической части работы будет реализован один из способов восстановления.  
